## libraries
library(rstanarm)
library(bigMap)
library(dplyr)
library(parallel)

#' Constructs a tsne object with all required elements by bigMap package
#' @param tsne A data.frame or matrix containing X, Y coordinates of a tsne embedding
#' @param ppx A number indicating the perplexity used in the tsne computation
#' @param data A data.frame or matrix with the data used to compute tsne
#' @param ... Additional arguments to be passed, if known (otherwise will be set up as NULL or similar)
#' check the output of \code{bdm.ptsne} or \code{bdm.bhtsne} in bigMap package
#' @return A tsne object that matches the structure of tsne outputs in bigMap package
init_tsne <- function(tsne, ppx, data, ...){
     args <- list(...)
     if(length(names(args)) != length(args)){
             stop('Argument list is not a named list. Please check argument names are provided.')
     }
     if(!'Xw' %in% names(args)){
             # whitened (pre-processed) data (check documentation of bigMap package)
             Xw <- bdm.data(data)[[1]][, ]
             colnames(Xw) <- colnames(data)
     }
     needed_args <- list(dSet = 'tSNE', is.distance = FALSE, is.sparse = FALSE,
                         normalize = FALSE, nX = nrow(data), mX = ncol(data),
                         ppx = list(ppx = ppx, xppx = NA, B = NA, t = NA),
                         t = list(), data = data, Xw = Xw, 
                         ptsne = list(Y = tsne[, 1:2]))
     
     L <- vector('list')
        
     
     n <- names(args)
     n <- n[n %in% names(needed_args)]
     if(length(n) > 0){
             for(arg in n){
                     L[[arg]] <- args[[arg]]
             }
             n <- names(needed_args)[!names(needed_args) %in% n]
             for(arg in n){
                     L[[arg]] <- needed_args[[arg]]
             }
     } else {
        L <- needed_args
     }
     
     L
}

#' Gets cluster labels for the duplicated rows that have not been used in the tsne
#' @param tsne A tsne instance as generated by \code{init_tsne}
#' @param data A data.frame containing sperm motility information
#' @param vars A character vector indicating the variables used in the tsne
#' The variables must also be present in the \code{data}!!
#' @return A data.frame containing \code{data} with two extra columns:
#' the cluster labels and merged cluster labels (equal to the previous if no merging was conducted)
assign_clusters <- function(tsne, data = sperm, vars = c('VCL', 'VSL', 'ALH', 'BCF')){
     
     if(!'data' %in% names(tsne)){
          if(is.list(tsne) && 'ptsne' %in% names(tsne)){
                  tsne <- init_tsne(tsne$ptsne$Y[, 1:2], data = data)
          } else if ((is.matrix(tsne) || is.data.frame(tsne)) && dim(tsne)[2] >= 2){
                  tsne <- init_tsne(tsne[, 1:2], data = data)
          } else {
                  stop('tsne parameter must be a tsne instance generated by "init_tsne"')
          }
          
     }
     
     # Find duplicated rows
     dpl_idx <- duplicated(data[, vars])
     
     # Find NA values in data (non-moving sperm)
     na_idx <- apply(data[, vars], 1, function(i) all(is.na(i)))
     
     # Indices of duplicated rows with available values (non-NA)
     idx <- which(dpl_idx == 1 & na_idx == 0)
     
     # Transform matrix of N dimensions (N = length(vars)) to a vector of characters
     str_rows <- apply(data[idx, vars], 1, paste, collapse = '+')
     str_data <- apply(tsne$data, 1, paste, collapse = '+')
     
     # Retrieve the row indices of the duplicated data
     match_idx <- match(str_rows, str_data)
     
     # Get cluster labels (merged and non-merged)
     mK <- bigMap::bdm.labels(tsne, merged = T)
     K <- bigMap::bdm.labels(tsne, merged = F)
     
     # Initialize cluster vector (merged and non-merged)
     v <- numeric(nrow(data))
     vK <- v
     
     # Replace with actual cluster labels
     v[!duplicated(data[, vars]) & na_idx == 0] <- K
     vK[!duplicated(data[, vars]) & na_idx == 0] <- mK
     
     # Get the corresponding cluster label for each duplicated row
     mK <- vapply(seq_along(match_idx), function(i) mK[match_idx[i]], numeric(1))
     K <- vapply(seq_along(match_idx), function(i) K[match_idx[i]], numeric(1))
     
     # Replace cluster labels 
     for(i in seq_along(idx)){
          v[idx[i]] <- K[i]
          vK[idx[i]] <- mK[i]
     }
     
     # Return the data with the cluster labels
     data$K <- v
     data$mK <- vK
     return(data)
}


#' Computes the proportions of sperm in each cluster, based on boar contribution
#' 
#' @param tsne A tsne instance, as generated by \code{init_tsne}
#' @param data A data.frame containing sperm motility data
#' @param fertility_data A data.frame containing insemination outcomes and other related data
#' @param do.merge A positive number (from 2 to number of clusters - 1), indicating 
#' the number of final clusters of the landscape (otherwise NA for no merging)
#' @param vars A character vector indicating the variables used in the tsne
#' @param cols A character vector indicating the data in fertility_data to be kept
#' @return A data.frame with the \code{cols} data and the proportions in each (merged) cluster
#' with i rows (i = nrow(fertility_data)) and j columns (length(cols) + number of clusters)
cluster_proportions <- function(tsne, data, fertility_data, do.merge = NA, 
                            vars = c('VCL', 'VSL', 'ALH', 'BCF'),
                            cols = c('Boar', 'Sow_parity', 'Success', 'Ejaculate')){
     
     # If merging is required, merge to k clusters (k = do.merge)
     if(!is.na(do.merge) & is.numeric(do.merge)){
             Xw <- tsne$XW
             df <- tsne$data
          tsne <- bdm.merge.s2nr(data = Xw, bdm = tsne, k = do.merge,
                                 info = FALSE, plot.merge = FALSE, ret.merge = TRUE)
     } 
        tsne$Xw <- Xw
        tsne$data <- df
     
     # Get cluster labels
     data <- assign_clusters(tsne, data)

     # Get sperm proportion in each cluster and get contribution of each boar
     tbl <- table(data$Boar, data$mK) / nrow(data)
     tbl <- as.data.frame.matrix(cbind(Boar = rownames(tbl), tbl))
     tbl[, -1] <- apply(tbl[, -1], 2, as.numeric)
     
     
     # Replicate proportions by boar N times (N = number of entries of each boar)
     ft_prop <- fertility_data[, cols]
     tmp <- do.call('rbind.data.frame', 
                    lapply(unique(ft_prop$Boar), function(i){
          do.call('rbind.data.frame', 
                  replicate(sum(ft_prop$Boar == i),
                            expr = tbl[tbl$Boar == i, 2:ncol(tbl)], 
                            simplify = FALSE))
     }))
     
     # Combine into a single data.frame, with the sow parity and insemination outcomes.
     ft_prop <- cbind(ft_prop, tmp)
     suppressWarnings(n <- !is.na(as.numeric(colnames(ft_prop))))
     suppressWarnings(colnames(ft_prop)[n] <- paste('k_', colnames(ft_prop)[n], sep = ''))
     colnames(ft_prop)[colnames(ft_prop) == 'k_0'] <- 'Static_prop'
     
     return(ft_prop)
}

#' Logistic regression model based on cluster proportions
#' 
#' @param ft_prop A data.frame containing the insemination outcomes and the "per boar" cluster proportions
#' (as returned by \code{cluster_proportions})
#' @param form A fomula to pass to the modelling function (as in glm or similar packages)
#' @param ... Parameters to be passed to the \code{stan_glmer} function
#' @return The model to predict fertility outcomes based on \code{form} and \code{ft_prop}
model_fertility <- function(ft_prop, form = NULL, ...){
     # chains = 4, cores = 4, iter = 4000, seed = 1923118, adapt_delta = 0.99, prior = normal(0, 5, autoscale = TRUE)

     if(is.null(form)) form <- formula(paste(
          paste('Success ~ (1|Boar) + Sow_parity + Static_prop +', sep = ''),
          paste(colnames(ft_prop)[grepl('k_', colnames(ft_prop))], collapse = ' + ', sep = ''), 
          collapse = ''
     ))
     
     if(length(list(...)) == 0){
          model <- stan_glmer(formula = form, data = ft_prop, family = binomial(link = 'logit'), 
                              chains = 4, cores = 4, iter = 4000, seed = 1923118, adapt_delta = 0.99,
                              prior = normal(0, 5, autoscale = TRUE))
     } else {
          model <- stan_glmer(formula = form, data = ft_prop, family = binomial(link = 'logit'), ...)
     }
     
     return(model)
}

#' Compute the predicted posterior distribution for each boar
#' @param model A model instance as generated by \code{model_fertility}, \code{stan_glmer} or similar
#' @param ft_prop A data.frame, as generated by \code{cluster_proportions}, 
#' containing the cluster proportions and insemination outcomes
#' @return A matrix of nrow = number of samples from the posterior distribution of the model
#' and ncol = number of boars
get_predictions <- function(model, ft_prop){

     # get a random row for each boar
     data2pred <- ft_prop %>% group_by(Boar) %>% sample_n(1)
     
     # get logodds
     logodds <- posterior_linpred(model, newdata = data2pred)
     
     # transform logodds to probability (of pregnancy)
     p <- apply(logodds, 2, function(i) exp(i) / (1+exp(i)))
     colnames(p) <- data2pred$Boar
     
     # reorder by median model fertiliy rate
     # eventual ties (unlikely) are break by uncertainty (quantile)
     p[, order(apply(p, 2, median), 
                   apply(p, 2, quantile, probs = 0.025),
                   decreasing = T)] 
}